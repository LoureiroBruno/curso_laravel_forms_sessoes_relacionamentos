================================================================================================================================================================================
mod 01

# Aprendemos a usar o método create das models do Eloquent
# Vimos para que serve o atributo fillable
# Aprendemos a agrupar nossas rotas

-----------------------------------------------------------------------------------------------------------------------------------

---------------------------------
 01
---------------------------------


## vamos começar a aprender alguns detalhes do framework laravel, vamos atingir o mesmo resultado mas com um código um pouco mais sucinto.
## Além de utilizar o próprio método input, posso acessar diretamente a propriedade.
exemplo:
ao invés de usar => $resquest->input('name_vindo_http_post')
pode usar => $resquest->name_vindo_http_post

então, se existe um campo "nome", vindo do ue está vindo no corpo da minha requisição, eu posso acessar diretamente a propriedade “Nome” do meu request.
desta forma eu consigo também pegar um array associativo com todos os dados da requisição. Imagina que na série, além do nome, eu também tivesse uma sinopse, uma descrição,
alguma coisa assim. Então, dessa forma, eu posso pegar todos os dados de uma vez, para adicionar na série.
Inclusive, falando em adicionar vários campos ao mesmo tempo, se eu tivesse vários campos, eu precisaria ter o nome, a descrição, atores e todos os campos que eu tivesse.
Só que o eloquent, que é o ORM do Laravel, já fornece uma forma de termos o que é chamado de mass assignment, ou atribuição em massa. Ou seja, preencher vários campos ao mesmo tempo.
E isso podemos fazer através de Serie::create():

Então toda model do eloquent possui esse método estático chamado create. E ele recebe por parâmetro um array associativo com todas as propriedades que eu quero armazenar, com todas
as colunas de banco de dados que eu quero armazenar.

exemplo:Serie::crete:([‘nome’ => 'name_vindo_http_post']); => de forma uninátia.

mas passamdo varios campos como citado no exemplo:
Serie::create($request->all()); => todos os parametros recebidos do request.

irá apresentar um erro pois
Então, como estou pegando tudo que vem do usuário, eu estou fazendo alterações que eu não queria, eu queria, por exemplo, só alterar o e-mail desse meu usuário, ou criar um novo usuário
só com nome e e-mail, sem esses dados de “admin”. Então, por isso ser perigoso, o Laravel obriga que informemos um detalhe.

Sempre que eu for utilizar mass assignment (atribuição em massa) preciso informar na minha “model”, quais campos podem ser atribuídos dessa forma.
Então, eu posso utilizar a propriedade fillable para isso, protected $fillable dentro da model usada, seguindo o exemplo model Serie.

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Serie extends Model
{
    use HasFactory;

    protected $fillable =
    [
        'nome', neste caso irá ignorar tudo o que não estiver nesta lista de campo de permissão a alteração
    ];
}

com isso ao usar o recurso do create() ao invés do save(), e ainda usando o create(pegando tudo o que vem do request ao inves de seguimentar o que pegar), ao usar create($request->all())
deve ser implementado na classe da model relacionada o uso de filtros, em simplicar o codigo nos controllers mas mantendo na camada de segurança.

com o uso dos metodos create(), alem de obter todos os parametros vindos do request, tambem pode usar como parametro o request->only(obtendo so os parametros desejados) e
request->except(obter todos os paramentros menos o que foi passado aqui)

---------------------------------
 02
---------------------------------

## Existem duas formas de agrupar. Uma, que já existe há algum tempo e já citamos, só que primeiro eu vou te mostrar uma forma que é nova na Laravel 9. Então, vamos dar uma olhada nela.
Se eu tenho vários ações diferentes vinda de um mesmo controller, eu posso ter um Route:controller() agrupando.
então Route::controller(controller:SeriesController::class)->group(function () {).
Então dentro eu passo uma função anônima, e nessa função anônima posso ter todas as definições de rotas.
exemplo:

/**
 * rotas de acesso dominio
 */
Route::get('/series', [SeriesController::class, 'index'])->name('indexSeries');
Route::get('/series/criar', [SeriesController::class, 'create'])->name('createSeries');
Route::post('/series/salvar', [SeriesController::class, 'store'])->name('storeSeries');

agrupando:

Route::controller(SeriesController::class)->group(function () {
    Route::get('/series','index')->name('series.index');
    Route::get('/series/criar','create')->name('series.create');
    Route::post('/series/salvar','store')->name('series.store');
});

não preciso mais informar a classe de forma resumda /nomedarota ,metodo

também pode aplicar o uso dos nomes das rotas, para o return das views, ou return redirect das views mais com os nomes das rotas.
exemplo:

    public function create()
    {
        return view('series.create(arquivo_da_view)'); ou return view(route('series.index')) ou return view->route('series.index');
    }


public function store(Request $request)
    {
        $nomeSerie = $request->input('nome');
        if ($nomeSerie != null) {
            Serie::create($request->all());
            return redirect('series(arquivo_da_view)') ou return redirect(route('series.index')) ou return redirect->route('series.index');
        }...
    }

    com paramentros
    return redirect('series')->with('success', 'Cadastro Realizado com Sucesso!'); ou return redirect()->route('series.index', ['success' => 'Cadastro Realizado com Sucesso!']);

    /** função pertecente ao Laravel 9.0 em diante */
    return to_route('series.index')->with('success', 'Cadastro Realizado com Sucesso!');

## diferença entre

/**
 * Grupo SerieController
 */
// Route::controller(SeriesController::class)->group(function () {
//     Route::get('/series','index')->name('series.index');
//     Route::get('/series/create','create')->name('series.create');
//     Route::post('/series/store','store')->name('series.store');
// });


e esse

/**
 * Grupo SerieController Recurso Route::Resource
 */
Route::resource('/series', SeriesController::class);

quando a rota possui possui o mesmo padrão acrescentando um sufixo tipo, series ou series/create ou series strore, tendo a ideia de criar, salvar, deletar seguindo a ideia do crud
para ficar um codigo mais enxuto, se seguir esse conceito


Verb	URI	Action	Route Name
GET	/photos	index	photos.index
GET	/photos/create	create	photos.create
POST	/photos	store	photos.store
GET	/photos/{photo}	show	photos.show
GET	/photos/{photo}/edit	edit	photos.edit
PUT/PATCH	/photos/{photo}	update	photos.update
DELETE	/photos/{photo}	destroy	photos.destroy

tem um controlador com esse os nomes desse metodos index, create, show, edit, update e destroy, pode com uma linha no exepmlo Route::resource('/series', SeriesController::class);
aplica as rotas, tendo que inserir apenas os nones das rotas nas actions do tipo href ou view ou redirect na referncia pra o controlador referenciado.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 02

# Aprendemos a utilizar o método destroy para remover dados do banco
# Entendemos como usar session com Laravel
# Utilizamos session para exibir flash messages
# Entendemos melhor sobre injeção de dependência com Laravel

-----------------------------------------------------------------------------------------------------------------------------------

---------------------------------
 02
---------------------------------

## Com essa forma de criar a rota em "create.blade.php" em Route::resource(name:'/series',controller:SeriesController::class);, já estou criando rotas que eu não tenho implementadas.
Por exemplo, a de deletar, de atualizar uma série, de exibir detalhes de uma série. Então, o que eu quero é informar que estou definindo um controller de resource, mas apenas para
algumas rotas. Então, como eu fiz com o meu request, eu posso utilizar os métodos except ou only.

Route::resource(name:'/series',controller:SeriesController::class)
->only([‘index’, ‘create’, ‘store’]);

ao acrescentar um nova rota do tipo delete, no caso um post para deletar um intem do banco, ja que o html so reconhe apenas os verbos post e get.
ficaria:
Route::post('series/destroy/{serie}', [SeriesController::class, 'destroy'])->name('series.destroy');

<form action="{{ route('series.destroy', $serie->id) }}" method="post" id="btn-destroy">
    @csrf
    <button type="submit" class="btn btn-outline-danger btn-sm mb-1">
        Excluir
    </button>
</form>


da mesma forma funcionaria inserindo no blade @method('DELETE)

Route::delete('series/destroy/{serie}', [SeriesController::class, 'destroy'])->name('series.destroy');

<form action="{{ route('series.destroy', $serie->id) }}" method="post" id="btn-destroy">
    @csrf
    @method('DELETE')
    <button type="submit" class="btn btn-outline-danger btn-sm mb-1">
        Excluir
    </button>
</form>

desta forma de enviar o @method('DELETE');
pode continuar usando o recurso do resource

Route::resource('/series', SeriesController::class)->only([
    'index',
    'create',
    'store',
    'destroy',
    'update'
]);


## a logica de funcionamento route::delete,
O que ele faz para criar essa rota é a barra e o que definimos, que no caso é “series”, e depois da barra e o que definimos no singular agora.
E o singular de “séries” em inglês é “series”. Então, por isso ele está passando esse parâmetro com o nome “series”. E como eu identifiquei que isso era o que estava acontecendo?
Eu peguei todos os parâmetros das minhas rotas.

por isso que no contorle obtem $request->serie;


---------------------------------
 06
---------------------------------

Então, quando eu utilizo o helper de session, ele não faz aquele flash. Então, para ter um flash, eu vou utilizar o meu request mesmo.
Então $request->session()->flash(‘mensagem.sucesso’, ‘Série adicionada com sucesso’), essa sintaxe sendo utilizada.

e mais interessante usar

controlador
    public function destroy(Serie $series)
    {
        if ($series != null) {
            $series->delete();

            return to_route('series.index')->with("sucess", "Excluído o Registro de n° {$series->id} com Sucesso!");
        } else {

            return to_route('series.index')->with("danger", "Nenhuma identificação no registro foi encontrado!");
        }
    }

view

         @if (session('success'))
                <div class="alert alert-success">
                    {{ session('success') }}
                </div>
            @elseif (session('danger'))
                <div class="alert alert-danger">
                    {{ session('danger') }}
                </div>
            @endif


do que este

controlador
  public function destroy(Request $request)
    {
        $idSerie = $request->series;
        if ($request->series != null) {
            Serie::destroy($request->series);
            $request->session()->put('mensagem.destroy', "Excluído o Registro de n° {$idSerie} com Sucesso!");

            /** enviado para a rota index que invia a view index */
            return to_route('series.index');
        } else {
            /** caso use session->flash desnecessário uso session()->forget() */
            $request->session()->put('mensagem.destroy', "Nenhuma identificação no registro foi encontrado!");

            return to_route('series.index');
        }
    }
view
            @isset($mensagemDestroy)
                <div class="alert alert-info">
                    {{ $mensagemDestroy }}
                </div>
            @endisset


---------------------------------
 07
---------------------------------
## Ao criar uma série, preciso pegar o nome essa série que foi criada para adicionar na mensagem. E esse método ::create, ou seja, o método estático create, já nos retorna a model que foi criada,
no caso uma série nossa.
Então, se eu já tenho a série em mãos, basta adicionar o nome dela na nossa mensagem. Então eu vou trocar para aspas duplas, para poder ter variáveis dentro, e eu vou informar que a {$serie-nome} foi adicionada.
Então, se eu adicionar uma série chamada “Teste”, ele vai dizer “Série Teste adicionada com sucesso”.


public function store(Request $request)
{
    if ($request->input('nome') != null) {
        $serie = Serie::create($request->all());

        return to_route('series.index')->with("success", "Cadastrado a série ({$serie->nome}) com sucesso!");
    } else {

        return redirect('series')->with("danger", "Há dados não informados, tente novamente!");
    }
}

Só que na hora de remover essa série, vamos de novo no código. Só que esse método destroy não vai devolver para nós qual foi a série removida.
Repara que o PHP Storm já me informa que o retorno dele é um inteiro de quantas séries foram removidas. não é isso que eu quero. Por que ela me devolve só isso?
Porque na prática, o que ele está fazendo por debaixo dos panos é como se fosse executar essa query DELETE FROM serie WHERE id = $request->series.

Serie::destroy($request->series); // DELETE FROM serie WHERE id = $request->series

Alternativa 01

public function destroy(Request $request)
{
    $idSerie = $request->series;
    if ($request->series != null) {
        Serie::destroy($request->series);
        $request->session()->put('mensagem.destroy', "Excluído o Registro de n° {$idSerie} com Sucesso!");

        /** enviado para a rota index que invia a view index */
        return to_route('series.index');
    } else {
        /** caso use session->flash desnecessário uso session()->forget() */
        $request->session()->put('mensagem.destroy', "Nenhuma identificação no registro foi encontrado!");

        return to_route('series.index');
    }
}

Então, eu consigo fazer isso de algumas formas. Primeiro, vou recuperar a série através de $serie = Serie::find($request->series);. O que esse método faz?
Ele encontra uma série baseada no seu ID, então vou passar o ID dessa série.
Então vamos fazer só um “dd”, para ver se eu vou ter acesso a essa série. Então dd($serie). Vamos lá, na hora que remover uma série, por exemplo “Teste”,
consegui encontrar e eu tenho minha série “Teste”.
Essa é uma forma. Só que tem uma outra forma um pouco mais interessante. O Laravel consegue nos ajudar em alguns cenários quando tenho parâmetros na rota.
Então, lembra que esse destroy a rota é /series/destroy/{series}?. Então, consigo ter um parâmetro chamado series, e ele nos traz alguma informação.
Qual informação? Depende do tipo que eu definir esse parâmetro. Vou te explicar o que isso quer dizer.
u vou ter um parâmetro chamado series e o tipo dele vai ser inteiro, por exemplo. Com isso, eu vou ter acesso ao ID da minha série. Então isso já deixa um pouco mais interessante o código.
Então vamos atualizar e garantir que tudo continua funcionando.
Então, repara que eu consegui buscar a série sem nem precisar adicionar código no meu controller, só de informar o parâmetro que eu estou utilizando public function destroy (Serie $series),
isso é bastante interessante.
Mas vamos lá, continuando, vou remover esse “dd”, e agora eu não preciso mais chamar esse método estático destroy, passando, por exemplo, dessa minha series o ID. Eu posso fazer isso sem problema nenhum,
mas posso também, direto da minha instância, chamar o método delete, então $series->delete()


ALternativa 02

public function destroy(Serie $series, Request $request)
    {
        if ($request->series != null) {
            $series->delete();
            $request->session()->put('mensagem.destroy', "Excluído o Registro de n° {$series->id} com Sucesso!");

            return to_route('series.index');
        } else {

            $request->session()->put('mensagem.destroy', "Nenhuma identificação no registro foi encontrado!");

            return to_route('series.index');
        }
    }


---------------------------------
 09
---------------------------------

## na edição de um registro passado por paramentro ao acinar o botão editar.
<form action="{{ route('series.edit', $serie->id) }}" method="get" id="btn-update">
    @csrf
    @method('EDIT')
    <button type="submit" class="btn btn-outline-dark btn-sm mb-1 ms-1">
        Editar
    </button>
</form>

criado um formulario com submit de id no verbo post, e sendo recebido no controlador edit, mas antes de ter passado pelo rota: series/series/edit
series dominio, segundo series éo parametro objeto, edit é o restante do nome da rota.

public function edit(Serie $series)
    {
        $series = $series->find($series->id);
        return view('series.edit')->with(
            ['series'=> $series]
        );
    }

e recebido na rota edit capturando o id passado por paramentro do obje series->id, e retornano a view com o objeto da linha selecionada de id.

recebida na view edit
<x-layout>
    <x-slot:title>
        Series - Alterar Item
        </x-slot>
        <x-slot:header>
            Editar Série: {{ $series->nome }}
            </x-slot>

            <x-series.form action="{{ route('series.update', $series->id) }}" nome="{{ $series->nome }}" />

            {{-- <form action="{{ route('series.update', $series->id) }}" method="post">
                @csrf
                @method('PATCH')
                <div class="mb-3">
                    <label for="nome" class="form-label">Nome</label>
                    <input type="nome" class="form-control" id="nome" name="nome" value="{{ $series->nome }}" placeholder="Nome do Título da Série">
                </div>
                <div class="col-auto">
                    <button type="submit" class="btn btn-primary btn-sm mb-3">Salvar</button>
                    <a href="{{ route('series.index') }}" class="btn btn-danger btn-sm mb-3" tabindex="-1" role="button"
                    aria-disabled="true">Cancelar</a>
                </div>
            </form> --}}
</x-layout>

que enseguinda é enviado ao metodo de update para efetuar a alteração
usado o componte da blade para o naõ execesso de repetição de código.

view edit

<x-layout>
    <x-slot:title>
        Series - Alterar Item
        </x-slot>
        <x-slot:header>
            Editar Série: {{ $series->nome }}
            </x-slot>

            <x-series.form action="{{ route('series.update', $series->id) }}" nome="{{ $series->nome }}" />

            {{-- <form action="{{ route('series.update', $series->id) }}" method="post">
                @csrf
                @method('PATCH')
                <div class="mb-3">
                    <label for="nome" class="form-label">Nome</label>
                    <input type="nome" class="form-control" id="nome" name="nome" value="{{ $series->nome }}" placeholder="Nome do Título da Série">
                </div>
                <div class="col-auto">
                    <button type="submit" class="btn btn-primary btn-sm mb-3">Salvar</button>
                    <a href="{{ route('series.index') }}" class="btn btn-danger btn-sm mb-3" tabindex="-1" role="button"
                    aria-disabled="true">Cancelar</a>
                </div>
            </form> --}}
</x-layout>

view create

<x-layout>
    <x-slot:title>
        Series - Cadastrar Item
        </x-slot>
        <x-slot:header>
            Nova Série
            </x-slot>

            <x-series.form action="{{ route('series.store') }}" />
            {{-- <form action="{{ route('series.store') }}" method="POST">
                @csrf
                <div class="mb-3">
                    <label for="nome" class="form-label">Nome</label>
                    <input type="nome" class="form-control" id="nome" name="nome" placeholder="Nome do Título da Série">
                </div>
                <div class="col-auto">
                    <button type="submit" class="btn btn-outline-primary btn-sm mb-3">Salvar</button>
                    <a href="{{ route('series.index') }}" class="btn btn-outline-danger btn-sm mb-3 ms-2" tabindex="-1" role="button"
                    aria-disabled="true">Cancelar</a>
                </div>
            </form> --}}
</x-layout>

herdado da view componetizado de form

<form action={{ $action }} method="POST">
    @csrf
    @isset($nome)
        @method('PUT')
    @endisset

    <div class="mb-3">
        <label for="nome" class="form-label">Nome</label>
        <input type="text" class="form-control" id="nome" name="nome" placeholder="Nome de Descrição Série"
            @isset($nome) value="{{ $nome }}" @endisset>
    </div>
    <div class="col-auto">
        <button type="submit" class="btn btn-outline-primary btn-sm mb-3">Salvar</button>
        <a href="{{ route('series.index') }}" class="btn btn-outline-danger btn-sm mb-3 ms-2" tabindex="-1"
            role="button" aria-disabled="true">Cancelar</a>
    </div>
</form>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 03

#

-----------------------------------------------------------------------------------------------------------------------------------
---------------------------------
 01
---------------------------------

## através do recurso de vadidação do lavarvel validate, torna mais simples no seus uso com relação ao um if por exemplo.
Só que imagina que eu tenha várias regras, o nome não pode ser nulo, ele tem que ter pelo menos 3 caracteres, a descrição também precisa ouvir. Eu ia encher o meu código de if,
ou esse if ia ficar muito grande. Além disso, eu ia acabar tendo que repetir tudo isso.

# Mas como eu crio essa validação?
Eu tenho um array de regras, e nessas regras eu informo que o meu “nome” tem tais regras, por exemplo, ’nome’ => ‘required’, ele é obrigatório.
E eu poderia ter outras regras, por exemplo, ele tem um número mínimo de caracteres, qual é o número mínimo?
Três caracteres, então ’nome’ => ‘required|min:3’.

## Então, eu posso fazer várias regras, separando por “ | “. Só que uma sintaxe que eu prefiro, que não era aceita em versões antigas do Laravel, mas já é há algum tempo,
posso utilizar um array, então ’nome’ => [‘required’, min:3’]. Então dessa forma, eu tenho o meu array de regras. De novo, eu tenho uma validação para o meu campo nome, em que ele
é obrigatório, e preciso de pelo menos 3 caracteres.

## entao nesse exemplo de validação simples ao inserir num formulario com o campo nome vazio, é redirecionado de volta ao formulario.
poŕem precisa ser melhor tratado essa validação tendo um fedback com o usuário.

---------------------------------
 04
---------------------------------

Então, eu comentei no vídeo anterior, que caso a validação não passe, o Laravel retorna uma resposta de redirecionamento para a página anterior.
E além disso, na flash message, ele adiciona todas as informações do request que não foi válido. Então conseguimos acessar o request.
mas se estivéssemos criando uma API, essa resposta de redirecionamento não seria interessante. Então, o que Laravel faz, é ao invés de retornar uma resposta de redirecionamento,
ele retorna um JSON já com as mensagens de erro para nós.

 O que acontece? Quando temos uma validação que falha, além de adicionar todos os campos, todo o input, todo o request no flash, ele também adiciona todos os erros, as mensagens de erro.
 E existe um detalhe por trás do Laravel, que transforma todos esses erros em uma variável já disponível para nós, chamada errors. Inclusive, na documentação neste link.
 já tem um HTML pronto para mostrar todas as mensagens de erro que existirem.

 view:

 @if ($errors->any())
    <div class="alert alert-danger">
        <ul>
            @foreach ($errors->all() as $error)
                <li>{{ $error }}</li>
            @endforeach
        </ul>
    </div>
@endif

desta fica desnecessário essa verificação:

controlador:
if ($request->input('nome') == null) {
    return redirect('series')->with("danger", "Há dados não informados, tente novamente!");
}

view:
@elseif (session('danger'))
    <div class="alert alert-danger">
        <img src="{{ asset('img/info.svg') }}" />
        {{ session('danger') }}
    </div>
@endif

## Então, com isso, já começamos a brincar com as validações, só que eu comentei que, de novo, além das mensagens de erro, o Laravel também coloca na flash toda a requisição.
Então, se eu quiser preencher esse campo, eu posso fazer da seguinte forma, eu vou para a view de create, e lembra que posso informar o nome de alguma forma?
Esse nome vai vir da minha sessão, vai vir da minha requisição anterior.
E para isso, o Laravel nos fornece uma função chamada old. Essa função pega da flash session, daquela sessão que dura uma vez só, a requisição anterior, que foi adicionada pela validação.
Assim, como eu tenho toda essa minha requisição, posso pegar o campo chamado “nome”.

Então, com isso, se eu adicionar somente um “A” no nome da série no navegador, tento inserir, ele volta e já preenche para nós. na ideia de facilitar a correção
Só que então entra um outro detalhe, que talvez você já perceba, vou inspecionar,e repara que agora eu acabei atualizando, estou tentando mandar esse novo formulário
com o valor do método como put.

<x-series.form action="{{ route('series.store') }}" :nome="old('nome')"/>

## poŕem na regra de negocio a aplicação apartir do momento que possue um valor na imput passar de update ao inves de um create
ao inves de verificar se existe um valor para um nome, e faz a veriifacao se é update É TRUE nas view principal form. pois na view de create seta com update true
 ## Ou seja, como se eu estivesse atualizando uma série existente. Então, preciso mudar aquela nossa lógica. No form, ao invés de verificar se o nome existe, vou simplesmente fazer um if,
 se o update existe e é verdadeiro, então @id($update).

 porém como as duas viwes compartilham ou usam do mesmo componente form, e cada um view possume metodos diferente foi alterando a logica do funcionamento do componente form

<form action={{ $action }} method="POST">
    @csrf
    {{-- @isset($nome) --}}
        @if ($update)
            @method('PUT')
        @endif
    {{-- @endisset --}}

    <div class="mb-3">
        <label for="nome" class="form-label">Nome</label>
        <input type="text" class="form-control" id="nome" name="nome" placeholder="Nome de Descrição Série"
            @isset($nome) value="{{ $nome }}" @endisset>
    </div>
    <div class="col-auto">
        <button type="submit" class="btn btn-outline-primary btn-sm mb-3">Salvar</button>
        <a href="{{ route('series.index') }}" class="btn btn-outline-danger btn-sm mb-3 ms-2" tabindex="-1"
            role="button" aria-disabled="true">Cancelar</a>
    </div>
</form>

acrescentando na view edit

  // <x-series.form action="{{ route('series.update', $series->id) }}" nome="{{ $series->nome }}" />
  <x-series.form action="{{ route('series.update', $series->id) }}" nome="{{ $series->nome }}" :update="true" />


---------------------------------
 06
---------------------------------

realizado a validação dos campos vindos do formulario da view create que é repassado ao metodo store, realizado a validaçao dos campos.
porém se quiser implementar a mesma regra de validação para a view de edit e respectivamente no seu metodo update
teria que copiar do metodo create?
Posso, ao invés de utilizar o request genérico do Laravel, criar o meu próprio request e já informar todas as regras necessárias.
vamos utilizar o Artisan, # php artisan make:request SeriesFormRequest.
Isso cria uma classe de request para nós. E eu informo o nome dessa classe, ou seja, uma requisição de um formulário de série, que tem as informações de uma série.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 04

#

-----------------------------------------------------------------------------------------------------------------------------------
##

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 05

#

-----------------------------------------------------------------------------------------------------------------------------------
##

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
