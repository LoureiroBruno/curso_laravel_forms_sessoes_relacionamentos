================================================================================================================================================================================
mod 01

# Aprendemos a usar o método create das models do Eloquent
# Vimos para que serve o atributo fillable
# Aprendemos a agrupar nossas rotas

-----------------------------------------------------------------------------------------------------------------------------------

---------------------------------
 01
---------------------------------


## vamos começar a aprender alguns detalhes do framework laravel, vamos atingir o mesmo resultado mas com um código um pouco mais sucinto.
## Além de utilizar o próprio método input, posso acessar diretamente a propriedade.
exemplo:
ao invés de usar => $resquest->input('name_vindo_http_post')
pode usar => $resquest->name_vindo_http_post

então, se existe um campo "nome", vindo do ue está vindo no corpo da minha requisição, eu posso acessar diretamente a propriedade “Nome” do meu request.
desta forma eu consigo também pegar um array associativo com todos os dados da requisição. Imagina que na série, além do nome, eu também tivesse uma sinopse, uma descrição,
alguma coisa assim. Então, dessa forma, eu posso pegar todos os dados de uma vez, para adicionar na série.
Inclusive, falando em adicionar vários campos ao mesmo tempo, se eu tivesse vários campos, eu precisaria ter o nome, a descrição, atores e todos os campos que eu tivesse.
Só que o eloquent, que é o ORM do Laravel, já fornece uma forma de termos o que é chamado de mass assignment, ou atribuição em massa. Ou seja, preencher vários campos ao mesmo tempo.
E isso podemos fazer através de Serie::create():

Então toda model do eloquent possui esse método estático chamado create. E ele recebe por parâmetro um array associativo com todas as propriedades que eu quero armazenar, com todas
as colunas de banco de dados que eu quero armazenar.

exemplo:Serie::crete:([‘nome’ => 'name_vindo_http_post']); => de forma uninátia.

mas passamdo varios campos como citado no exemplo:
Serie::create($request->all()); => todos os parametros recebidos do request.

irá apresentar um erro pois
Então, como estou pegando tudo que vem do usuário, eu estou fazendo alterações que eu não queria, eu queria, por exemplo, só alterar o e-mail desse meu usuário, ou criar um novo usuário
só com nome e e-mail, sem esses dados de “admin”. Então, por isso ser perigoso, o Laravel obriga que informemos um detalhe.

Sempre que eu for utilizar mass assignment (atribuição em massa) preciso informar na minha “model”, quais campos podem ser atribuídos dessa forma.
Então, eu posso utilizar a propriedade fillable para isso, protected $fillable dentro da model usada, seguindo o exemplo model Serie.

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Serie extends Model
{
    use HasFactory;

    protected $fillable =
    [
        'nome', neste caso irá ignorar tudo o que não estiver nesta lista de campo de permissão a alteração
    ];
}

com isso ao usar o recurso do create() ao invés do save(), e ainda usando o create(pegando tudo o que vem do request ao inves de seguimentar o que pegar), ao usar create($request->all())
deve ser implementado na classe da model relacionada o uso de filtros, em simplicar o codigo nos controllers mas mantendo na camada de segurança.

com o uso dos metodos create(), alem de obter todos os parametros vindos do request, tambem pode usar como parametro o request->only(obtendo so os parametros desejados) e
request->except(obter todos os paramentros menos o que foi passado aqui)

---------------------------------
 02
---------------------------------

## Existem duas formas de agrupar. Uma, que já existe há algum tempo e já citamos, só que primeiro eu vou te mostrar uma forma que é nova na Laravel 9. Então, vamos dar uma olhada nela.
Se eu tenho vários ações diferentes vinda de um mesmo controller, eu posso ter um Route:controller() agrupando.
então Route::controller(controller:SeriesController::class)->group(function () {).
Então dentro eu passo uma função anônima, e nessa função anônima posso ter todas as definições de rotas.
exemplo:

/**
 * rotas de acesso dominio
 */
Route::get('/series', [SeriesController::class, 'index'])->name('indexSeries');
Route::get('/series/criar', [SeriesController::class, 'create'])->name('createSeries');
Route::post('/series/salvar', [SeriesController::class, 'store'])->name('storeSeries');

agrupando:

Route::controller(SeriesController::class)->group(function () {
    Route::get('/series','index')->name('series.index');
    Route::get('/series/criar','create')->name('series.create');
    Route::post('/series/salvar','store')->name('series.store');
});

não preciso mais informar a classe de forma resumda /nomedarota ,metodo

também pode aplicar o uso dos nomes das rotas, para o return das views, ou return redirect das views mais com os nomes das rotas.
exemplo:

    public function create()
    {
        return view('series.create(arquivo_da_view)'); ou return view(route('series.index')) ou return view->route('series.index');
    }


public function store(Request $request)
    {
        $nomeSerie = $request->input('nome');
        if ($nomeSerie != null) {
            Serie::create($request->all());
            return redirect('series(arquivo_da_view)') ou return redirect(route('series.index')) ou return redirect->route('series.index');
        }...
    }

    com paramentros
    return redirect('series')->with('success', 'Cadastro Realizado com Sucesso!'); ou return redirect()->route('series.index', ['success' => 'Cadastro Realizado com Sucesso!']);

    /** função pertecente ao Laravel 9.0 em diante */
    return to_route('series.index')->with('success', 'Cadastro Realizado com Sucesso!');

## diferença entre

/**
 * Grupo SerieController
 */
// Route::controller(SeriesController::class)->group(function () {
//     Route::get('/series','index')->name('series.index');
//     Route::get('/series/create','create')->name('series.create');
//     Route::post('/series/store','store')->name('series.store');
// });


e esse

/**
 * Grupo SerieController Recurso Route::Resource
 */
Route::resource('/series', SeriesController::class);

quando a rota possui possui o mesmo padrão acrescentando um sufixo tipo, series ou series/create ou series strore, tendo a ideia de criar, salvar, deletar seguindo a ideia do crud
para ficar um codigo mais enxuto, se seguir esse conceito


Verb	URI	Action	Route Name
GET	/photos	index	photos.index
GET	/photos/create	create	photos.create
POST	/photos	store	photos.store
GET	/photos/{photo}	show	photos.show
GET	/photos/{photo}/edit	edit	photos.edit
PUT/PATCH	/photos/{photo}	update	photos.update
DELETE	/photos/{photo}	destroy	photos.destroy

tem um controlador com esse os nomes desse metodos index, create, show, edit, update e destroy, pode com uma linha no exepmlo Route::resource('/series', SeriesController::class);
aplica as rotas, tendo que inserir apenas os nones das rotas nas actions do tipo href ou view ou redirect na referncia pra o controlador referenciado.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 02

# Aprendemos a utilizar o método destroy para remover dados do banco
# Entendemos como usar session com Laravel
# Utilizamos session para exibir flash messages
# Entendemos melhor sobre injeção de dependência com Laravel

-----------------------------------------------------------------------------------------------------------------------------------

---------------------------------
 02
---------------------------------

## Com essa forma de criar a rota em "create.blade.php" em Route::resource(name:'/series',controller:SeriesController::class);, já estou criando rotas que eu não tenho implementadas.
Por exemplo, a de deletar, de atualizar uma série, de exibir detalhes de uma série. Então, o que eu quero é informar que estou definindo um controller de resource, mas apenas para
algumas rotas. Então, como eu fiz com o meu request, eu posso utilizar os métodos except ou only.

Route::resource(name:'/series',controller:SeriesController::class)
->only([‘index’, ‘create’, ‘store’]);

ao acrescentar um nova rota do tipo delete, no caso um post para deletar um intem do banco, ja que o html so reconhe apenas os verbos post e get.
ficaria:
Route::post('series/destroy/{serie}', [SeriesController::class, 'destroy'])->name('series.destroy');

<form action="{{ route('series.destroy', $serie->id) }}" method="post" id="btn-destroy">
    @csrf
    <button type="submit" class="btn btn-outline-danger btn-sm mb-1">
        Excluir
    </button>
</form>


da mesma forma funcionaria inserindo no blade @method('DELETE)

Route::delete('series/destroy/{serie}', [SeriesController::class, 'destroy'])->name('series.destroy');

<form action="{{ route('series.destroy', $serie->id) }}" method="post" id="btn-destroy">
    @csrf
    @method('DELETE')
    <button type="submit" class="btn btn-outline-danger btn-sm mb-1">
        Excluir
    </button>
</form>

desta forma de enviar o @method('DELETE');
pode continuar usando o recurso do resource

Route::resource('/series', SeriesController::class)->only([
    'index',
    'create',
    'store',
    'destroy',
    'update'
]);


## a logica de funcionamento route::delete,
O que ele faz para criar essa rota é a barra e o que definimos, que no caso é “series”, e depois da barra e o que definimos no singular agora.
E o singular de “séries” em inglês é “series”. Então, por isso ele está passando esse parâmetro com o nome “series”. E como eu identifiquei que isso era o que estava acontecendo?
Eu peguei todos os parâmetros das minhas rotas.

por isso que no contorle obtem $request->serie;


---------------------------------
 06
---------------------------------

Então, quando eu utilizo o helper de session, ele não faz aquele flash. Então, para ter um flash, eu vou utilizar o meu request mesmo.
Então $request->session()->flash(‘mensagem.sucesso’, ‘Série adicionada com sucesso’), essa sintaxe sendo utilizada.

e mais interessante usar

controlador
    public function destroy(Serie $series)
    {
        if ($series != null) {
            $series->delete();

            return to_route('series.index')->with("sucess", "Excluído o Registro de n° {$series->id} com Sucesso!");
        } else {

            return to_route('series.index')->with("danger", "Nenhuma identificação no registro foi encontrado!");
        }
    }

view

         @if (session('success'))
                <div class="alert alert-success">
                    {{ session('success') }}
                </div>
            @elseif (session('danger'))
                <div class="alert alert-danger">
                    {{ session('danger') }}
                </div>
            @endif


do que este

controlador
  public function destroy(Request $request)
    {
        $idSerie = $request->series;
        if ($request->series != null) {
            Serie::destroy($request->series);
            $request->session()->put('mensagem.destroy', "Excluído o Registro de n° {$idSerie} com Sucesso!");

            /** enviado para a rota index que invia a view index */
            return to_route('series.index');
        } else {
            /** caso use session->flash desnecessário uso session()->forget() */
            $request->session()->put('mensagem.destroy', "Nenhuma identificação no registro foi encontrado!");

            return to_route('series.index');
        }
    }
view
            @isset($mensagemDestroy)
                <div class="alert alert-info">
                    {{ $mensagemDestroy }}
                </div>
            @endisset



****
outras forma de execução
****

public function update(Request $request, Serie $series)
    {
        /** atualizar registro de acordo com id passado por parametro */
        // if ($series != null) {
        //     $series->where('id', $series->id)->update(['nome' => $request->nome]);
        //     return to_route('series.index')->with("success", "Atualizado a série: '{$request->nome}' com sucesso!");
        // } else {
        //     return redirect('series')->with("danger", "Há dados não informados, tente novamente!");
        // }

        /** mais simples */
        if ($request->nome == null) {
            return to_route('series.index')->with("danger", "Não foi possível realizar atualização de cadastro");
        }

        $series->fill($request->all());
        $series->save();
        return to_route('series.index')->with("success", "Atualizado a série: '{$series->nome}' com sucesso!");
    }

****

---------------------------------
 07
---------------------------------
## Ao criar uma série, preciso pegar o nome essa série que foi criada para adicionar na mensagem. E esse método ::create, ou seja, o método estático create, já nos retorna a model que foi criada,
no caso uma série nossa.
Então, se eu já tenho a série em mãos, basta adicionar o nome dela na nossa mensagem. Então eu vou trocar para aspas duplas, para poder ter variáveis dentro, e eu vou informar que a {$serie-nome} foi adicionada.
Então, se eu adicionar uma série chamada “Teste”, ele vai dizer “Série Teste adicionada com sucesso”.


public function store(Request $request)
{
    if ($request->input('nome') != null) {
        $serie = Serie::create($request->all());

        return to_route('series.index')->with("success", "Cadastrado a série ({$serie->nome}) com sucesso!");
    } else {

        return redirect('series')->with("danger", "Há dados não informados, tente novamente!");
    }
}

Só que na hora de remover essa série, vamos de novo no código. Só que esse método destroy não vai devolver para nós qual foi a série removida.
Repara que o PHP Storm já me informa que o retorno dele é um inteiro de quantas séries foram removidas. não é isso que eu quero. Por que ela me devolve só isso?
Porque na prática, o que ele está fazendo por debaixo dos panos é como se fosse executar essa query DELETE FROM serie WHERE id = $request->series.

Serie::destroy($request->series); // DELETE FROM serie WHERE id = $request->series

Alternativa 01

public function destroy(Request $request)
{
    $idSerie = $request->series;
    if ($request->series != null) {
        Serie::destroy($request->series);
        $request->session()->put('mensagem.destroy', "Excluído o Registro de n° {$idSerie} com Sucesso!");

        /** enviado para a rota index que invia a view index */
        return to_route('series.index');
    } else {
        /** caso use session->flash desnecessário uso session()->forget() */
        $request->session()->put('mensagem.destroy', "Nenhuma identificação no registro foi encontrado!");

        return to_route('series.index');
    }
}

Então, eu consigo fazer isso de algumas formas. Primeiro, vou recuperar a série através de $serie = Serie::find($request->series);. O que esse método faz?
Ele encontra uma série baseada no seu ID, então vou passar o ID dessa série.
Então vamos fazer só um “dd”, para ver se eu vou ter acesso a essa série. Então dd($serie). Vamos lá, na hora que remover uma série, por exemplo “Teste”,
consegui encontrar e eu tenho minha série “Teste”.
Essa é uma forma. Só que tem uma outra forma um pouco mais interessante. O Laravel consegue nos ajudar em alguns cenários quando tenho parâmetros na rota.
Então, lembra que esse destroy a rota é /series/destroy/{series}?. Então, consigo ter um parâmetro chamado series, e ele nos traz alguma informação.
Qual informação? Depende do tipo que eu definir esse parâmetro. Vou te explicar o que isso quer dizer.
u vou ter um parâmetro chamado series e o tipo dele vai ser inteiro, por exemplo. Com isso, eu vou ter acesso ao ID da minha série. Então isso já deixa um pouco mais interessante o código.
Então vamos atualizar e garantir que tudo continua funcionando.
Então, repara que eu consegui buscar a série sem nem precisar adicionar código no meu controller, só de informar o parâmetro que eu estou utilizando public function destroy (Serie $series),
isso é bastante interessante.
Mas vamos lá, continuando, vou remover esse “dd”, e agora eu não preciso mais chamar esse método estático destroy, passando, por exemplo, dessa minha series o ID. Eu posso fazer isso sem problema nenhum,
mas posso também, direto da minha instância, chamar o método delete, então $series->delete()


ALternativa 02

public function destroy(Serie $series, Request $request)
    {
        if ($request->series != null) {
            $series->delete();
            $request->session()->put('mensagem.destroy', "Excluído o Registro de n° {$series->id} com Sucesso!");

            return to_route('series.index');
        } else {

            $request->session()->put('mensagem.destroy', "Nenhuma identificação no registro foi encontrado!");

            return to_route('series.index');
        }
    }


---------------------------------
 09
---------------------------------

## na edição de um registro passado por paramentro ao acinar o botão editar.
<form action="{{ route('series.edit', $serie->id) }}" method="get" id="btn-update">
    @csrf
    @method('EDIT')
    <button type="submit" class="btn btn-outline-dark btn-sm mb-1 ms-1">
        Editar
    </button>
</form>

criado um formulario com submit de id no verbo post, e sendo recebido no controlador edit, mas antes de ter passado pelo rota: series/series/edit
series dominio, segundo series éo parametro objeto, edit é o restante do nome da rota.

public function edit(Serie $series)
    {
        $series = $series->find($series->id);
        return view('series.edit')->with(
            ['series'=> $series]
        );
    }

e recebido na rota edit capturando o id passado por paramentro do obje series->id, e retornano a view com o objeto da linha selecionada de id.

recebida na view edit
<x-layout>
    <x-slot:title>
        Series - Alterar Item
        </x-slot>
        <x-slot:header>
            Editar Série: {{ $series->nome }}
            </x-slot>

            <x-series.form action="{{ route('series.update', $series->id) }}" nome="{{ $series->nome }}" />

            {{-- <form action="{{ route('series.update', $series->id) }}" method="post">
                @csrf
                @method('PATCH')
                <div class="mb-3">
                    <label for="nome" class="form-label">Nome</label>
                    <input type="nome" class="form-control" id="nome" name="nome" value="{{ $series->nome }}" placeholder="Nome do Título da Série">
                </div>
                <div class="col-auto">
                    <button type="submit" class="btn btn-primary btn-sm mb-3">Salvar</button>
                    <a href="{{ route('series.index') }}" class="btn btn-danger btn-sm mb-3" tabindex="-1" role="button"
                    aria-disabled="true">Cancelar</a>
                </div>
            </form> --}}
</x-layout>

que enseguinda é enviado ao metodo de update para efetuar a alteração
usado o componte da blade para o naõ execesso de repetição de código.

view edit

<x-layout>
    <x-slot:title>
        Series - Alterar Item
        </x-slot>
        <x-slot:header>
            Editar Série: {{ $series->nome }}
            </x-slot>

            <x-series.form action="{{ route('series.update', $series->id) }}" nome="{{ $series->nome }}" />

            {{-- <form action="{{ route('series.update', $series->id) }}" method="post">
                @csrf
                @method('PATCH')
                <div class="mb-3">
                    <label for="nome" class="form-label">Nome</label>
                    <input type="nome" class="form-control" id="nome" name="nome" value="{{ $series->nome }}" placeholder="Nome do Título da Série">
                </div>
                <div class="col-auto">
                    <button type="submit" class="btn btn-primary btn-sm mb-3">Salvar</button>
                    <a href="{{ route('series.index') }}" class="btn btn-danger btn-sm mb-3" tabindex="-1" role="button"
                    aria-disabled="true">Cancelar</a>
                </div>
            </form> --}}
</x-layout>

view create

<x-layout>
    <x-slot:title>
        Series - Cadastrar Item
        </x-slot>
        <x-slot:header>
            Nova Série
            </x-slot>

            <x-series.form action="{{ route('series.store') }}" />
            {{-- <form action="{{ route('series.store') }}" method="POST">
                @csrf
                <div class="mb-3">
                    <label for="nome" class="form-label">Nome</label>
                    <input type="nome" class="form-control" id="nome" name="nome" placeholder="Nome do Título da Série">
                </div>
                <div class="col-auto">
                    <button type="submit" class="btn btn-outline-primary btn-sm mb-3">Salvar</button>
                    <a href="{{ route('series.index') }}" class="btn btn-outline-danger btn-sm mb-3 ms-2" tabindex="-1" role="button"
                    aria-disabled="true">Cancelar</a>
                </div>
            </form> --}}
</x-layout>

herdado da view componetizado de form

<form action={{ $action }} method="POST">
    @csrf
    @isset($nome)
        @method('PUT')
    @endisset

    <div class="mb-3">
        <label for="nome" class="form-label">Nome</label>
        <input type="text" class="form-control" id="nome" name="nome" placeholder="Nome de Descrição Série"
            @isset($nome) value="{{ $nome }}" @endisset>
    </div>
    <div class="col-auto">
        <button type="submit" class="btn btn-outline-primary btn-sm mb-3">Salvar</button>
        <a href="{{ route('series.index') }}" class="btn btn-outline-danger btn-sm mb-3 ms-2" tabindex="-1"
            role="button" aria-disabled="true">Cancelar</a>
    </div>
</form>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 03

# Aprendemos a validar os dados de uma requisição
# Vimos que podemos ter várias regras de validação para cada campo
# Entendemos como podemos exibir todos os erros de validação em nossas views
# Aprendemos a extrair um FormRequest para melhorar nosso código
# Vimos como traduzir as mensagens de erro

-----------------------------------------------------------------------------------------------------------------------------------
---------------------------------
 01
---------------------------------

## através do recurso de vadidação do lavarvel validate, torna mais simples no seus uso com relação ao um if por exemplo.
Só que imagina que eu tenha várias regras, o nome não pode ser nulo, ele tem que ter pelo menos 3 caracteres, a descrição também precisa ouvir. Eu ia encher o meu código de if,
ou esse if ia ficar muito grande. Além disso, eu ia acabar tendo que repetir tudo isso.

# Mas como eu crio essa validação?
Eu tenho um array de regras, e nessas regras eu informo que o meu “nome” tem tais regras, por exemplo, ’nome’ => ‘required’, ele é obrigatório.
E eu poderia ter outras regras, por exemplo, ele tem um número mínimo de caracteres, qual é o número mínimo?
Três caracteres, então ’nome’ => ‘required|min:3’.

## Então, eu posso fazer várias regras, separando por “ | “. Só que uma sintaxe que eu prefiro, que não era aceita em versões antigas do Laravel, mas já é há algum tempo,
posso utilizar um array, então ’nome’ => [‘required’, min:3’]. Então dessa forma, eu tenho o meu array de regras. De novo, eu tenho uma validação para o meu campo nome, em que ele
é obrigatório, e preciso de pelo menos 3 caracteres.

## entao nesse exemplo de validação simples ao inserir num formulario com o campo nome vazio, é redirecionado de volta ao formulario.
poŕem precisa ser melhor tratado essa validação tendo um fedback com o usuário.

---------------------------------
 04
---------------------------------

Então, eu comentei no vídeo anterior, que caso a validação não passe, o Laravel retorna uma resposta de redirecionamento para a página anterior.
E além disso, na flash message, ele adiciona todas as informações do request que não foi válido. Então conseguimos acessar o request.
mas se estivéssemos criando uma API, essa resposta de redirecionamento não seria interessante. Então, o que Laravel faz, é ao invés de retornar uma resposta de redirecionamento,
ele retorna um JSON já com as mensagens de erro para nós.

 O que acontece? Quando temos uma validação que falha, além de adicionar todos os campos, todo o input, todo o request no flash, ele também adiciona todos os erros, as mensagens de erro.
 E existe um detalhe por trás do Laravel, que transforma todos esses erros em uma variável já disponível para nós, chamada errors. Inclusive, na documentação neste link.
 já tem um HTML pronto para mostrar todas as mensagens de erro que existirem.

 view:

 @if ($errors->any())
    <div class="alert alert-danger">
        <ul>
            @foreach ($errors->all() as $error)
                <li>{{ $error }}</li>
            @endforeach
        </ul>
    </div>
@endif

desta fica desnecessário essa verificação:

controlador:
if ($request->input('nome') == null) {
    return redirect('series')->with("danger", "Há dados não informados, tente novamente!");
}

view:
@elseif (session('danger'))
    <div class="alert alert-danger">
        <img src="{{ asset('img/info.svg') }}" />
        {{ session('danger') }}
    </div>
@endif

## Então, com isso, já começamos a brincar com as validações, só que eu comentei que, de novo, além das mensagens de erro, o Laravel também coloca na flash toda a requisição.
Então, se eu quiser preencher esse campo, eu posso fazer da seguinte forma, eu vou para a view de create, e lembra que posso informar o nome de alguma forma?
Esse nome vai vir da minha sessão, vai vir da minha requisição anterior.
E para isso, o Laravel nos fornece uma função chamada old. Essa função pega da flash session, daquela sessão que dura uma vez só, a requisição anterior, que foi adicionada pela validação.
Assim, como eu tenho toda essa minha requisição, posso pegar o campo chamado “nome”.

Então, com isso, se eu adicionar somente um “A” no nome da série no navegador, tento inserir, ele volta e já preenche para nós. na ideia de facilitar a correção
Só que então entra um outro detalhe, que talvez você já perceba, vou inspecionar,e repara que agora eu acabei atualizando, estou tentando mandar esse novo formulário
com o valor do método como put.

<x-series.form action="{{ route('series.store') }}" :nome="old('nome')"/>

## poŕem na regra de negocio a aplicação apartir do momento que possue um valor na imput passar de update ao inves de um create
ao inves de verificar se existe um valor para um nome, e faz a veriifacao se é update É TRUE nas view principal form. pois na view de create seta com update true
 ## Ou seja, como se eu estivesse atualizando uma série existente. Então, preciso mudar aquela nossa lógica. No form, ao invés de verificar se o nome existe, vou simplesmente fazer um if,
 se o update existe e é verdadeiro, então @id($update).

 porém como as duas viwes compartilham ou usam do mesmo componente form, e cada um view possume metodos diferente foi alterando a logica do funcionamento do componente form

<form action={{ $action }} method="POST">
    @csrf
    {{-- @isset($nome) --}}
        @if ($update)
            @method('PUT')
        @endif
    {{-- @endisset --}}

    <div class="mb-3">
        <label for="nome" class="form-label">Nome</label>
        <input type="text" class="form-control" id="nome" name="nome" placeholder="Nome de Descrição Série"
            @isset($nome) value="{{ $nome }}" @endisset>
    </div>
    <div class="col-auto">
        <button type="submit" class="btn btn-outline-primary btn-sm mb-3">Salvar</button>
        <a href="{{ route('series.index') }}" class="btn btn-outline-danger btn-sm mb-3 ms-2" tabindex="-1"
            role="button" aria-disabled="true">Cancelar</a>
    </div>
</form>

acrescentando na view edit

  // <x-series.form action="{{ route('series.update', $series->id) }}" nome="{{ $series->nome }}" />
  <x-series.form action="{{ route('series.update', $series->id) }}" nome="{{ $series->nome }}" :update="true" />


---------------------------------
 06
---------------------------------

realizado a validação dos campos vindos do formulario da view create que é repassado ao metodo store, realizado a validaçao dos campos.
porém se quiser implementar a mesma regra de validação para a view de edit e respectivamente no seu metodo update
teria que copiar do metodo create?
Posso, ao invés de utilizar o request genérico do Laravel, criar o meu próprio request e já informar todas as regras necessárias.
vamos utilizar o Artisan, # php artisan make:request SeriesFormRequest.
Isso cria uma classe de request para nós. E eu informo o nome dessa classe, ou seja, uma requisição de um formulário de série, que tem as informações de uma série.

Ele vai criar para nós, posso subir o meu Artisan Serve de novo. E onde que esse Request foi criado?
Ele foi criado na pasta “App > http > requests”,e dentro dela, a nossa classe já estende um FormRequest do Laravel.
com isso posso implementar essa classe recem criada coma as regras de validação, a onde quiser.
Pois toda a requisição será enviada a classe criada SeriesFormRequest e dela será tratada com as implementações da Classe Request.Porém usa ela ao inves da Classe Request

## desabilitar a regra de autenticação na classe SeriesFormRequest

## Agora, se eu quiser modificar essas mensagens, podemos fazer de duas formas, uma é no próprio FormRequest. Imagina que eu queira uma mensagem personalizada para o nome de uma série.
Então, quando tem qualquer erro com o nome de uma série, quero uma mensagem personalizada.
Eu posso implementar o método messages. Ele retorna um array com todas as mensagens que eu posso utilizar. Então, por exemplo, se eu tiver qualquer erro com o nome, por exemplo, ’nome.required’,
ou seja, se a regra required não for satisfeita para o campo nome, eu posso exibir a mensagem “O campo nome é obrigatório”, então ’nome.required’ => ‘O campo nome é obrigatório’.
Então, eu poderia ter, por exemplo, ’nome.min’ => ‘O campo nome precisa de pelo menos 3 caracteres’, que é a regra min do campo nome, vai gerar essa mensagem.
Só que esse 3 é configurável, poderia mudar de 3 para 2, então eu posso utilizar o atributo :min para informar, então ’nome.min’ => ‘O campo nome precisa de pelo menos :min caracteres’

public function messages()
{
    return [
        'nome.required' => 'O campo nome é obrigatório',
        'min' => 'O campo nome requer no mínimo de :min caracteres'
    ];
}

Se quiser criar uma mensagem personalizada para todos os erros de nome, basta usar:

public function messages()
{
    return [
        'nome.required' => 'O campo nome é obrigatório e precisa no mímino de 3 caracteres',
    ];
}

então a ideias da função messeges é personalizar as mensagem dos metodos especificos para mensagens especificas. pq no caso não criando o metodo messages irá tudo funcionar
mas com o reorno das mensagens no modelo padrão do framework que no caso ainda em ingles.

## mas se no caso é apenas traduzir as mensagens de retorno, sem necessáriamente personalizar.
pode ir na pasta lang e baixar as traduções. ou ir na pasta config e no arquivo de configuração do app e na opção locale que por padrão esta em locale='en'
ou uma outra maneira não muito recomenda acessar a pasta lang/en/validation.php e alterar o conteudo das mensagem nos atributos estabelecidos no framework.

exemplo: eu posso colocar
’required => ‘O campo :atribute é obrigatório’.
’string’ => ‘O campo :atribute precisa ter pelo menos :min caracteres.’.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 04

Aprendemos sobre os tipos de relacionamentos do Eloquent
Criamos os relacionamentos de nossas models
Aprendemos a utilizar escopos
Conhecemos o conceito de eager loading com Eloquent

-----------------------------------------------------------------------------------------------------------------------------------

---------------------------------
 02
---------------------------------

## aso você já tenha feito os cursos de Doctrine, por exemplo, você lembra que temos entidades que não dependem do ORM, elas só têm algumas anotações ou atributos.
Pois existem uma outra classe EntityManager que gerencia as entidades e seus relacionamentos.
no nosso caso, nossa entidade, que é uma classe normal do PHP, teríamos um atributo de temporadas, por exemplo, algo como private array $temporadas;. E até poderíamos especificar que esse
array é de temporadas.
Então teríamos algo parecido com esse código. E poderíamos ter um método getter, para acessar as temporadas. Só que como já comentei, o Eloquent ORM utiliza um padrão diferente, ele não
utiliza esse data maper, esse mapeamento de dados. Assim, se fosse o caso, inclusive, eu teria um private string $nome.
Mas para definirmos um relacionamento com o Eloquent ORM, nós não vamos criar uma propriedade nova, nós vamos criar um método de relacionamento.
Só que antes de criarmos o relacionamento entre série e uma temporada, por exemplo, preciso ter essa temporada. Então vamos criar as models de temporada e de episódio.
Então vou abrir o meu terminal, vou interromper o meu Artisan Serve, e vou rodar php artisan make:model Season -m e ao invés de chamar de temporada, eu vou começar a escrever em inglês,
então vai ser season.

# php artisan make:model Season -m (-m já cria a migration referente a model Season)
# php artisan make:model Season -m (-m já cria a migration referente a model Season)

## Vamos dar uma olhada em Season.php. Eu tenho a model de temporada e a model de episódio. Então vamos voltar para a série, Serie.php. Em algum momento que tenha a série, eu quero poder acessar suas temporadas.
Mas eu já falei que eu não vou criar essa propriedade, então para acessar, vou criar um método de relacionamento.

Então eu vou criar um public function temporadas() e o nome desse método é o nome pelo qual eu quero acessar esse relacionamento. Se quando eu tiver uma série, eu quiser acessar temporadas,
vou criar um método chamado temporadas.

simples assim, tenho um método de relacionamento, e ele precisa retornar alguma forma de relacionamento. E temos várias. No caso, uma série tem várias temporadas, posso simplesmente escrever isso em inglês, dizendo que essa série has many,
ou seja, “tem muitas temporadas”, no nosso caso, “season”, return $this->hasMany(related: Season::class);.
Então, o que isso está fazendo, ele está informando que uma série vai ter um relacionamento com a model de temporada do tipo 1 para muitos. Uma série possui várias temporadas.

public function seasons()
{
    /** Uma seria para muitas temporadas */
    return $this->hasMany(related: Season::class);
}

Inclusive, posso fazer o relacionamento inverso também,
posso dizer que uma temporada pertence a alguma série, então eu vou criar um método de série, ou no caso, como estamos escrevendo em inglês, series, public functon series().
Embora isso seja singular, termina com “s” por causa do inglês.


Mas enfim, essa temporada tem uma série, ela pertence a uma série. Posso retornar informando que return $this->belongsTo(Serie::class). Relacionamento definido.

Agora, uma temporada tem também muitos episódios, então vamos lá, public function episodes(), e eu posso definir no retorno return $this->hasMany(Episode::class). Mesma coisa na classe de episódio, eu posso mapear a temporada, então public function season(),
que vai retornar return $this->belongsTo(Season::class).


Com isso, tenho todas as minhas models com os seus relacionamentos definidos

---------------------------------
 04
---------------------------------

E detalhes. Primeiro, ele está montando a query, utilizando como chave estrangeira uma coluna chamada ”serie_id”, só que eu quero começar a escrever em inglês, então vai ser ”series_id”, ou seja, vai ter um “s” no final. O que eu posso fazer?
No relacionamento de série com temporadas, além de informar com qual classe ela vai se relacionar, posso informar qual nome da chave estrangeira, no caso vai ser ”series_id”.

public function seasons()
{
    /** Uma seria possue muitas temporadas */
    return $this->hasMany(related: Season::class, foreignKey:'series_id');
}

 Com isso, se eu atualizar, ele já passa a utilizar a coluna ”series_id”. Assim, conseguimos personalizar o nosso modelo do banco de dados. Caso eu precisasse fazer com que essa chave estrangeira referencie uma coluna na minha tabela, que não é a minha chave primária,
 eu poderia informar o último parâmetro localKey.


public function seasons()
{
    /** Uma seria possue muitas temporadas */
    return $this->hasMany(related: Season::class, foreignKey:'series_id', localkey:'id');
}

O padrão é sempre ID? O padrão é o que definimos em $primaryKey, que por padrão, é ID, mas eu poderia alterar isso para ser ”series_id”, por exemplo. Que isso seria chave primária da minha tabela de séries.

## relacionamentos possíveis que o Eloquent fornece:

** "one to one": um relacionamento de um para um, por exemplo, um usuário possui um endereço, e se essas models realmente existem de forma independente, ou seja, em tabelas diferentes, preciso usar o relacionamento On To One
OBS:: "one to one" semelhante "has One Throught"

** "one to many":
um para muitos, em que uma série possui várias temporadas. Uma temporada tem vários episódios. E cada um desses relacionamentos possui o inverso. Então, o inverso do One To Many, é o Belongs To, uma temporada pertence a uma série, um episódio pertence a uma temporada.
OBS:: "one to many" semelhante "has Many Throught"

** "many to many":
é o de muitos para muitos, por exemplo, na Alura, um aluno pode fazer vários cursos, e um curso pode ter vários alunos matriculados, isso é o Many To Many. Inclusive, precisamos de uma tabela intermediária para fazer isso


"Through":
Esses relacionamentos do tipo Through são iguais ao seus parentes, vamos dizer assim, então por exemplo, Has One é parecido com o One To One e Has Many é parecido com o One To Many,
só que esse Through significa que existe uma outra tabela envolvida nesse relacionamento, e podemos passar por ela.

Por exemplo, imagina que temos um mecânico, esse mecânico trabalha em um carro, e esse carro tem um dono, eu consigo a partir do mecânico, acessar o dono do carro através desse relacionamento
de Has One Through

##  Entendido mais ou menos, mesmo que por cima, os tipos de relacionamentos.
## vamos criar a migration,
dentro da model season verificando. O que uma season tem?
Ela já tem o seu ID, ela tem os timestamps, quando a season foi criada. Agora, vou ter também algum INTEIRO para fazer o RELACIONAMENTO com o ID da Serie.

ó que o que acontece?,
dentro da MODEL serie, quando eu tenho esse ID, como é o caso da minha série, esse ID cria uma coluna do tipo bigIncrement, e ele usa esse tipo unsignedBigInteger.
O que isso quer dizer?
É um tipo inteiro maior e só positivo.

Então, se vamos fazer um relacionamento com esse tipo de coluna, vamos criar também um unsignedBigInteger dentro da MODEL Season.
Então vamos chamar de ”series_id”, e ele não vai ser autoincrement, é só isso. tendo um relacionamento entre as MODEL de Season e MODEL Serie,


** onde dentro da model season

 public function up()
    {
        Schema::create('seasons', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('series_id'); onde a coluna series_id se relaciona com coluna id da model Serie
            $table->timestamps();
        });
    }


 tenho a minha coluna de series_id, mas eu não tenho aquela minha chave estrangeira. Para eu criar a chave estrangeira, eu posso utilizar o método foreign.
 Então, a minha series_id é uma chave estrangeira, que referencia a coluna ID na tabela, ou seja, on(table: ‘series’).

 $table->foreign('series_id')->references('id')->on('series');

  public function up()
    {
        Schema::create('seasons', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('series_id'); onde a coluna series_id se relaciona com coluna id da model Serie
             $table->foreign('series_id')->references('id')->on('series');
            $table->timestamps();
        });
    }

## finalizando o relacionamento entre temporadas e séries. Mas repare que isso é bastante verboso. Para facilitar um pouco, o Laravel fornece essa outra sintaxe,
que é o $table->foreignID(column: ‘series_id’)->constrained.

Essa parte: $table->foreignID(column: ‘series_id’)
cria o campo que é unsignedBigInteger com esse nome.

E essa parte: ->constrained
faz o relacionamento, ele pega o nome do campo e referência uma coluna ID, a chave primária da tabela que estamos nos relacionando.

    public function up()
    {
        Schema::create('seasons', function (Blueprint $table) {
            $table->id();
            $table->unsignedTinyInteger('numero');
            $table->foreignId('series_id')->constrained();
            $table->timestamps();
        });
    }

--------------------------------
Se todos os nossos valores forem padrão ou corretamente configurados, podemos usar também o método foreignIdFor (que existe desde o Laravel 8)
 que recebe por parâmetro o nome da model ao invés do nome da coluna. Um exemplo, nesse nosso caso, seria:

$table->foreignIdFor(Serie::class)->constrained();

mas no nosso exemplo:

Nesse caso nós acabaríamos tendo a coluna como serie_id ao invés de series_id.
Entao, Podemos ainda passar um segundo parâmetro para esse método, ficando:

$table->foreignIdFor(Serie::class, ‘series_id’)->constrained();
--------------------------------


## Se ao invés de acessar a propriedade;
  public function edit(Serie $series)
    {
        dd($series->seasons);
        return view('series.edit')->with(
                                            ['series'=> $series]
                                        );
    }
acessar o metodo

public function edit(Serie $series)
{
    dd($series->seasons());
    return view('series.edit')->with(
                                        ['series'=> $series]
                                    );
}

obtem o acesso ao relacionamento.
com isso tendo acesso ao relacionamento, consigo modificar a query, por exemplo, adicionar um campo, fazer um filtro por esse relacionamento. Então,
quero pegar dessa minha série somente a temporada com o ID 1, ou seja, dd($series->temporadas()->whereId()->get());, enfim, eu consigo modificar essa query e no final fazer um get.

** propriedade e metodo
uma propriedade, eu acesso a coleção, já pego as temporadas. Se eu acessar através do método tenho o relacionamento, o query builder, ou seja, uma possibilidade de filtrar isso,
para depois pegar a coleção.


---------------------------------
 06
---------------------------------

primeiro realizado a condição dentro do controlador SerieController no metodo index, listar o campo nome de ordem crescente

/**
* list series function
*
* @return string
*/
public function index()
{

/** configurado na model Serie o metodo booted orderBy */
$series = Serie::orderBy('nome', 'asc')->get();
return view('series.index')->with('series', $series);

}

então criando escopos do tipo global.
criado um metodo booted dentro da MODEL usada Serie, contruindo com mesma condição de ordernar de forma crescente no campo nome e repasando ao controlador SerieController o filtro já
estabelecido

na model:

/**
    * The "booted" method of the model.
    *
    * @return void
    */
protected static function booted()
{
    static::addGlobalScope('ordered', function (Builder $builder) {
        $builder->orderBy('nome');
    });
}

no controller refatorado

/**
* list series function
*
* @return string
*/
public function index()
{

/** recebendo do model Serie ordenado por nome asc */
$series = Serie::all();

return view('series.index')->with('series', $series);

}

criando espoco local
E o que acontece, existem outras formas de adicionarmos escopos, eu poderia, por exemplo, imagina que tenho usuários e quero ver somente os usuários ativos.
Eu posso criar um escopo local, chamado scopeActive, por exemplo, e esse escopo vai receber também um query builder, então public function scopeActive(Builder $query),
e ele vai retornar essa query com algum filtro, por exemplo, return $query->qhere(column: ‘active’, operator: true), e é igual a true ou 1, ou o campo que você quiser buscar no banco de dados.

## na abordagem de como trazer os demais dados com as model realacionadas, iŕa depender da necessidade, seguindo o projeto criado.
Eu tenho em minha série, as temporadas, sempre que quiser buscar uma série, essa série virá sem suas temporadas, e se tento acessar, só então o Eloquent busca as temporadas no banco.
O nome disso é lazy loading, para que eu não precise ficar buscando dados que são desnecessários.
Mas se em todo o momento precisar ficar indo as temporadas dessa série, vou na próxima série, busco as temporadas, imagina que na minha view, na minha index, onde eu estou exibindo os nomes das séries,
também estou exibindo quantas temporadas tenho.

## então o mais indicado é buscar tudo de uma vez dentro de um limite de qantidade de itens, como a paginação.
em uma busca das minhas séries, por exemplo, trazer as séries com as temporadas, posso fazer isso através do método with. O controller poderia fazer com o método with,
então $series = Serie::with(‘temporadas’), então posso passar todos os relacionamentos que quero adicionar. E isso vai nos retornar o nosso query builder, então eu posso buscar.

Isso, nessa nossa página, vai gerar o mesmo resultado, só que com uma perda de performance, porque agora eu estou acessando as temporadas que inicialmente não precisava.
Mas, esse código vai continuar funcionando. E guanha performance depois evitando que seja executado varias consulta dentero daquela paginação na busca por temporadas(season)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 05

#

-----------------------------------------------------------------------------------------------------------------------------------
## refatorando o codigo, indo ate as mogrations e reescrevendo as migrations de season e episodes
Quando eu excluir uma série, quero garantir que ele também vai excluir as temporadas, os episódios. Então no nosso constrain, vou dizer que ondDelete(‘cascade’). Ou seja,
quando eu deletar uma série também vou deletar todas as suas temporadas.

 $table->foreignId('series_id')->constrained()->onDelete('cascade');

 O ideal não seria criar uma nova migration?
 Seria, só que no meu caso vou zerar a minha base de dados, vou recriar todas as migrations, então não vai ter problema, podemos recriar tudo.

 # php artisan migrate:fresh
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
