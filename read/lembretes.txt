================================================================================================================================================================================
mod 01

#

-----------------------------------------------------------------------------------------------------------------------------------

---------------------------------
 01
---------------------------------


## vamos começar a aprender alguns detalhes do framework laravel, vamos atingir o mesmo resultado mas com um código um pouco mais sucinto.
## Além de utilizar o próprio método input, posso acessar diretamente a propriedade.
exemplo:
ao invés de usar => $resquest->input('name_vindo_http_post')
pode usar => $resquest->name_vindo_http_post

então, se existe um campo "nome", vindo do ue está vindo no corpo da minha requisição, eu posso acessar diretamente a propriedade “Nome” do meu request.
desta forma eu consigo também pegar um array associativo com todos os dados da requisição. Imagina que na série, além do nome, eu também tivesse uma sinopse, uma descrição,
alguma coisa assim. Então, dessa forma, eu posso pegar todos os dados de uma vez, para adicionar na série.
Inclusive, falando em adicionar vários campos ao mesmo tempo, se eu tivesse vários campos, eu precisaria ter o nome, a descrição, atores e todos os campos que eu tivesse.
Só que o eloquent, que é o ORM do Laravel, já fornece uma forma de termos o que é chamado de mass assignment, ou atribuição em massa. Ou seja, preencher vários campos ao mesmo tempo.
E isso podemos fazer através de Serie::create():

Então toda model do eloquent possui esse método estático chamado create. E ele recebe por parâmetro um array associativo com todas as propriedades que eu quero armazenar, com todas
as colunas de banco de dados que eu quero armazenar.

exemplo:Serie::crete:([‘nome’ => 'name_vindo_http_post']); => de forma uninátia.

mas passamdo varios campos como citado no exemplo:
Serie::create($request->all()); => todos os parametros recebidos do request.

irá apresentar um erro pois
Então, como estou pegando tudo que vem do usuário, eu estou fazendo alterações que eu não queria, eu queria, por exemplo, só alterar o e-mail desse meu usuário, ou criar um novo usuário
só com nome e e-mail, sem esses dados de “admin”. Então, por isso ser perigoso, o Laravel obriga que informemos um detalhe.

Sempre que eu for utilizar mass assignment (atribuição em massa) preciso informar na minha “model”, quais campos podem ser atribuídos dessa forma.
Então, eu posso utilizar a propriedade fillable para isso, protected $fillable dentro da model usada, seguindo o exemplo model Serie.

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Serie extends Model
{
    use HasFactory;

    protected $fillable =
    [
        'nome', neste caso irá ignorar tudo o que não estiver nesta lista de campo de permissão a alteração
    ];
}

com isso ao usar o recurso do create() ao invés do save(), e ainda usando o create(pegando tudo o que vem do request ao inves de seguimentar o que pegar), ao usar create($request->all())
deve ser implementado na classe da model relacionada o uso de filtros, em simplicar o codigo nos controllers mas mantendo na camada de segurança.

com o uso dos metodos create(), alem de obter todos os parametros vindos do request, tambem pode usar como parametro o request->only(obtendo so os parametros desejados) e
request->except(obter todos os paramentros menos o que foi passado aqui)

---------------------------------
 02
---------------------------------

## Existem duas formas de agrupar. Uma, que já existe há algum tempo e já citamos, só que primeiro eu vou te mostrar uma forma que é nova na Laravel 9. Então, vamos dar uma olhada nela.
Se eu tenho vários ações diferentes vinda de um mesmo controller, eu posso ter um Route:controller() agrupando.
então Route::controller(controller:SeriesController::class)->group(function () {).
Então dentro eu passo uma função anônima, e nessa função anônima posso ter todas as definições de rotas.
exemplo:

/**
 * rotas de acesso dominio
 */
Route::get('/series', [SeriesController::class, 'index'])->name('indexSeries');
Route::get('/series/criar', [SeriesController::class, 'create'])->name('createSeries');
Route::post('/series/salvar', [SeriesController::class, 'store'])->name('storeSeries');

agrupando:

Route::controller(SeriesController::class)->group(function () {
    Route::get('/series','index')->name('series.index');
    Route::get('/series/criar','create')->name('series.create');
    Route::post('/series/salvar','store')->name('series.store');
});

não preciso mais informar a classe de forma resumda /nomedarota ,metodo

também pode aplicar o uso dos nomes das rotas, para o return das views, ou return redirect das views mais com os nomes das rotas.
exemplo:

    public function create()
    {
        return view('series.create(arquivo_da_view)'); ou return view(route('series.index')) ou return view->route('series.index');
    }


public function store(Request $request)
    {
        $nomeSerie = $request->input('nome');
        if ($nomeSerie != null) {
            Serie::create($request->all());
            return redirect('series(arquivo_da_view)') ou return redirect(route('series.index')) ou return redirect->route('series.index');
        }...
    }

    com paramentros
    return redirect('series')->with('success', 'Cadastro Realizado com Sucesso!'); ou return redirect()->route('series.index', ['success' => 'Cadastro Realizado com Sucesso!']);

    /** função pertecente ao Laravel 9.0 em diante */
    return to_route('series.index')->with('success', 'Cadastro Realizado com Sucesso!');

## diferença entre

/**
 * Grupo SerieController
 */
// Route::controller(SeriesController::class)->group(function () {
//     Route::get('/series','index')->name('series.index');
//     Route::get('/series/create','create')->name('series.create');
//     Route::post('/series/store','store')->name('series.store');
// });


e esse

/**
 * Grupo SerieController Recurso Route::Resource
 */
Route::resource('/series', SeriesController::class);

quando a rota possui possui o mesmo padrão acrescentando um sufixo tipo, series ou series/create ou series strore, tendo a ideia de criar, salvar, deletar seguindo a ideia do crud
para ficar um codigo mais enxuto, se seguir esse conceito


Verb	URI	Action	Route Name
GET	/photos	index	photos.index
GET	/photos/create	create	photos.create
POST	/photos	store	photos.store
GET	/photos/{photo}	show	photos.show
GET	/photos/{photo}/edit	edit	photos.edit
PUT/PATCH	/photos/{photo}	update	photos.update
DELETE	/photos/{photo}	destroy	photos.destroy

tem um controlador com esse os nomes desse metodos index, create, show, edit, update e destroy, pode com uma linha no exepmlo Route::resource('/series', SeriesController::class);
aplica as rotas, tendo que inserir apenas os nones das rotas nas actions do tipo href ou view ou redirect na referncia pra o controlador referenciado.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 02

#

-----------------------------------------------------------------------------------------------------------------------------------
##

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 03

#

-----------------------------------------------------------------------------------------------------------------------------------
##

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 04

#

-----------------------------------------------------------------------------------------------------------------------------------
##

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 05

#

-----------------------------------------------------------------------------------------------------------------------------------
##

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
