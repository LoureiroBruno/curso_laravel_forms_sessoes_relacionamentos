================================================================================================================================================================================
mod 01

# Aprendemos a usar o método create das models do Eloquent
# Vimos para que serve o atributo fillable
# Aprendemos a agrupar nossas rotas

-----------------------------------------------------------------------------------------------------------------------------------

---------------------------------
 01
---------------------------------


## vamos começar a aprender alguns detalhes do framework laravel, vamos atingir o mesmo resultado mas com um código um pouco mais sucinto.
## Além de utilizar o próprio método input, posso acessar diretamente a propriedade.
exemplo:
ao invés de usar => $resquest->input('name_vindo_http_post')
pode usar => $resquest->name_vindo_http_post

então, se existe um campo "nome", vindo do ue está vindo no corpo da minha requisição, eu posso acessar diretamente a propriedade “Nome” do meu request.
desta forma eu consigo também pegar um array associativo com todos os dados da requisição. Imagina que na série, além do nome, eu também tivesse uma sinopse, uma descrição,
alguma coisa assim. Então, dessa forma, eu posso pegar todos os dados de uma vez, para adicionar na série.
Inclusive, falando em adicionar vários campos ao mesmo tempo, se eu tivesse vários campos, eu precisaria ter o nome, a descrição, atores e todos os campos que eu tivesse.
Só que o eloquent, que é o ORM do Laravel, já fornece uma forma de termos o que é chamado de mass assignment, ou atribuição em massa. Ou seja, preencher vários campos ao mesmo tempo.
E isso podemos fazer através de Serie::create():

Então toda model do eloquent possui esse método estático chamado create. E ele recebe por parâmetro um array associativo com todas as propriedades que eu quero armazenar, com todas
as colunas de banco de dados que eu quero armazenar.

exemplo:Serie::crete:([‘nome’ => 'name_vindo_http_post']); => de forma uninátia.

mas passamdo varios campos como citado no exemplo:
Serie::create($request->all()); => todos os parametros recebidos do request.

irá apresentar um erro pois
Então, como estou pegando tudo que vem do usuário, eu estou fazendo alterações que eu não queria, eu queria, por exemplo, só alterar o e-mail desse meu usuário, ou criar um novo usuário
só com nome e e-mail, sem esses dados de “admin”. Então, por isso ser perigoso, o Laravel obriga que informemos um detalhe.

Sempre que eu for utilizar mass assignment (atribuição em massa) preciso informar na minha “model”, quais campos podem ser atribuídos dessa forma.
Então, eu posso utilizar a propriedade fillable para isso, protected $fillable dentro da model usada, seguindo o exemplo model Serie.

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Serie extends Model
{
    use HasFactory;

    protected $fillable =
    [
        'nome', neste caso irá ignorar tudo o que não estiver nesta lista de campo de permissão a alteração
    ];
}

com isso ao usar o recurso do create() ao invés do save(), e ainda usando o create(pegando tudo o que vem do request ao inves de seguimentar o que pegar), ao usar create($request->all())
deve ser implementado na classe da model relacionada o uso de filtros, em simplicar o codigo nos controllers mas mantendo na camada de segurança.

com o uso dos metodos create(), alem de obter todos os parametros vindos do request, tambem pode usar como parametro o request->only(obtendo so os parametros desejados) e
request->except(obter todos os paramentros menos o que foi passado aqui)

---------------------------------
 02
---------------------------------

## Existem duas formas de agrupar. Uma, que já existe há algum tempo e já citamos, só que primeiro eu vou te mostrar uma forma que é nova na Laravel 9. Então, vamos dar uma olhada nela.
Se eu tenho vários ações diferentes vinda de um mesmo controller, eu posso ter um Route:controller() agrupando.
então Route::controller(controller:SeriesController::class)->group(function () {).
Então dentro eu passo uma função anônima, e nessa função anônima posso ter todas as definições de rotas.
exemplo:

/**
 * rotas de acesso dominio
 */
Route::get('/series', [SeriesController::class, 'index'])->name('indexSeries');
Route::get('/series/criar', [SeriesController::class, 'create'])->name('createSeries');
Route::post('/series/salvar', [SeriesController::class, 'store'])->name('storeSeries');

agrupando:

Route::controller(SeriesController::class)->group(function () {
    Route::get('/series','index')->name('series.index');
    Route::get('/series/criar','create')->name('series.create');
    Route::post('/series/salvar','store')->name('series.store');
});

não preciso mais informar a classe de forma resumda /nomedarota ,metodo

também pode aplicar o uso dos nomes das rotas, para o return das views, ou return redirect das views mais com os nomes das rotas.
exemplo:

    public function create()
    {
        return view('series.create(arquivo_da_view)'); ou return view(route('series.index')) ou return view->route('series.index');
    }


public function store(Request $request)
    {
        $nomeSerie = $request->input('nome');
        if ($nomeSerie != null) {
            Serie::create($request->all());
            return redirect('series(arquivo_da_view)') ou return redirect(route('series.index')) ou return redirect->route('series.index');
        }...
    }

    com paramentros
    return redirect('series')->with('success', 'Cadastro Realizado com Sucesso!'); ou return redirect()->route('series.index', ['success' => 'Cadastro Realizado com Sucesso!']);

    /** função pertecente ao Laravel 9.0 em diante */
    return to_route('series.index')->with('success', 'Cadastro Realizado com Sucesso!');

## diferença entre

/**
 * Grupo SerieController
 */
// Route::controller(SeriesController::class)->group(function () {
//     Route::get('/series','index')->name('series.index');
//     Route::get('/series/create','create')->name('series.create');
//     Route::post('/series/store','store')->name('series.store');
// });


e esse

/**
 * Grupo SerieController Recurso Route::Resource
 */
Route::resource('/series', SeriesController::class);

quando a rota possui possui o mesmo padrão acrescentando um sufixo tipo, series ou series/create ou series strore, tendo a ideia de criar, salvar, deletar seguindo a ideia do crud
para ficar um codigo mais enxuto, se seguir esse conceito


Verb	URI	Action	Route Name
GET	/photos	index	photos.index
GET	/photos/create	create	photos.create
POST	/photos	store	photos.store
GET	/photos/{photo}	show	photos.show
GET	/photos/{photo}/edit	edit	photos.edit
PUT/PATCH	/photos/{photo}	update	photos.update
DELETE	/photos/{photo}	destroy	photos.destroy

tem um controlador com esse os nomes desse metodos index, create, show, edit, update e destroy, pode com uma linha no exepmlo Route::resource('/series', SeriesController::class);
aplica as rotas, tendo que inserir apenas os nones das rotas nas actions do tipo href ou view ou redirect na referncia pra o controlador referenciado.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 02

#

-----------------------------------------------------------------------------------------------------------------------------------

---------------------------------
 02
---------------------------------

## Com essa forma de criar a rota em "create.blade.php" em Route::resource(name:'/series',controller:SeriesController::class);, já estou criando rotas que eu não tenho implementadas.
Por exemplo, a de deletar, de atualizar uma série, de exibir detalhes de uma série. Então, o que eu quero é informar que estou definindo um controller de resource, mas apenas para
algumas rotas. Então, como eu fiz com o meu request, eu posso utilizar os métodos except ou only.

Route::resource(name:'/series',controller:SeriesController::class)
->only([‘index’, ‘create’, ‘store’]);

ao acrescentar um nova rota do tipo delete, no caso um post para deletar um intem do banco, ja que o html so reconhe apenas os verbos post e get.
ficaria:
Route::post('series/destroy/{serie}', [SeriesController::class, 'destroy'])->name('series.destroy');

<form action="{{ route('series.destroy', $serie->id) }}" method="post" id="btn-destroy">
    @csrf
    <button type="submit" class="btn btn-outline-danger btn-sm mb-1">
        Excluir
    </button>
</form>


da mesma forma funcionaria inserindo no blade @method('DELETE)

Route::delete('series/destroy/{serie}', [SeriesController::class, 'destroy'])->name('series.destroy');

<form action="{{ route('series.destroy', $serie->id) }}" method="post" id="btn-destroy">
    @csrf
    @method('DELETE')
    <button type="submit" class="btn btn-outline-danger btn-sm mb-1">
        Excluir
    </button>
</form>

desta forma de enviar o @method('DELETE');
pode continuar usando o recurso do resource

Route::resource('/series', SeriesController::class)->only([
    'index',
    'create',
    'store',
    'destroy',
    'update'
]);


## a logica de funcionamento route::delete,
O que ele faz para criar essa rota é a barra e o que definimos, que no caso é “series”, e depois da barra e o que definimos no singular agora.
E o singular de “séries” em inglês é “series”. Então, por isso ele está passando esse parâmetro com o nome “series”. E como eu identifiquei que isso era o que estava acontecendo?
Eu peguei todos os parâmetros das minhas rotas.

por isso que no contorle obtem $request->serie;


---------------------------------
 06
---------------------------------

Então, quando eu utilizo o helper de session, ele não faz aquele flash. Então, para ter um flash, eu vou utilizar o meu request mesmo.
Então $request->session()->flash(‘mensagem.sucesso’, ‘Série adicionada com sucesso’), essa sintaxe sendo utilizada.

e mais interessante usar

controlador
    public function destroy(Serie $series)
    {
        if ($series != null) {
            $series->delete();

            return to_route('series.index')->with("sucess", "Excluído o Registro de n° {$series->id} com Sucesso!");
        } else {

            return to_route('series.index')->with("danger", "Nenhuma identificação no registro foi encontrado!");
        }
    }

view

         @if (session('success'))
                <div class="alert alert-success">
                    {{ session('success') }}
                </div>
            @elseif (session('danger'))
                <div class="alert alert-danger">
                    {{ session('danger') }}
                </div>
            @endif


do que este

controlador
  public function destroy(Request $request)
    {
        $idSerie = $request->series;
        if ($request->series != null) {
            Serie::destroy($request->series);
            $request->session()->put('mensagem.destroy', "Excluído o Registro de n° {$idSerie} com Sucesso!");

            /** enviado para a rota index que invia a view index */
            return to_route('series.index');
        } else {
            /** caso use session->flash desnecessário uso session()->forget() */
            $request->session()->put('mensagem.destroy', "Nenhuma identificação no registro foi encontrado!");

            return to_route('series.index');
        }
    }
view
            @isset($mensagemDestroy)
                <div class="alert alert-info">
                    {{ $mensagemDestroy }}
                </div>
            @endisset


---------------------------------
 07
---------------------------------
## Ao criar uma série, preciso pegar o nome essa série que foi criada para adicionar na mensagem. E esse método ::create, ou seja, o método estático create, já nos retorna a model que foi criada,
no caso uma série nossa.
Então, se eu já tenho a série em mãos, basta adicionar o nome dela na nossa mensagem. Então eu vou trocar para aspas duplas, para poder ter variáveis dentro, e eu vou informar que a {$serie-nome} foi adicionada.
Então, se eu adicionar uma série chamada “Teste”, ele vai dizer “Série Teste adicionada com sucesso”.


public function store(Request $request)
{
    if ($request->input('nome') != null) {
        $serie = Serie::create($request->all());

        return to_route('series.index')->with("success", "Cadastrado a série ({$serie->nome}) com sucesso!");
    } else {

        return redirect('series')->with("danger", "Há dados não informados, tente novamente!");
    }
}

Só que na hora de remover essa série, vamos de novo no código. Só que esse método destroy não vai devolver para nós qual foi a série removida.
Repara que o PHP Storm já me informa que o retorno dele é um inteiro de quantas séries foram removidas. não é isso que eu quero. Por que ela me devolve só isso?
Porque na prática, o que ele está fazendo por debaixo dos panos é como se fosse executar essa query DELETE FROM serie WHERE id = $request->series.

Serie::destroy($request->series); // DELETE FROM serie WHERE id = $request->series

Alternativa 01

public function destroy(Request $request)
{
    $idSerie = $request->series;
    if ($request->series != null) {
        Serie::destroy($request->series);
        $request->session()->put('mensagem.destroy', "Excluído o Registro de n° {$idSerie} com Sucesso!");

        /** enviado para a rota index que invia a view index */
        return to_route('series.index');
    } else {
        /** caso use session->flash desnecessário uso session()->forget() */
        $request->session()->put('mensagem.destroy', "Nenhuma identificação no registro foi encontrado!");

        return to_route('series.index');
    }
}

Então, eu consigo fazer isso de algumas formas. Primeiro, vou recuperar a série através de $serie = Serie::find($request->series);. O que esse método faz?
Ele encontra uma série baseada no seu ID, então vou passar o ID dessa série.
Então vamos fazer só um “dd”, para ver se eu vou ter acesso a essa série. Então dd($serie). Vamos lá, na hora que remover uma série, por exemplo “Teste”,
consegui encontrar e eu tenho minha série “Teste”.
Essa é uma forma. Só que tem uma outra forma um pouco mais interessante. O Laravel consegue nos ajudar em alguns cenários quando tenho parâmetros na rota.
Então, lembra que esse destroy a rota é /series/destroy/{series}?. Então, consigo ter um parâmetro chamado series, e ele nos traz alguma informação.
Qual informação? Depende do tipo que eu definir esse parâmetro. Vou te explicar o que isso quer dizer.
u vou ter um parâmetro chamado series e o tipo dele vai ser inteiro, por exemplo. Com isso, eu vou ter acesso ao ID da minha série. Então isso já deixa um pouco mais interessante o código.
Então vamos atualizar e garantir que tudo continua funcionando.
Então, repara que eu consegui buscar a série sem nem precisar adicionar código no meu controller, só de informar o parâmetro que eu estou utilizando public function destroy (Serie $series),
isso é bastante interessante.
Mas vamos lá, continuando, vou remover esse “dd”, e agora eu não preciso mais chamar esse método estático destroy, passando, por exemplo, dessa minha series o ID. Eu posso fazer isso sem problema nenhum,
mas posso também, direto da minha instância, chamar o método delete, então $series->delete()


ALternativa 02

public function destroy(Serie $series, Request $request)
    {
        if ($request->series != null) {
            $series->delete();
            $request->session()->put('mensagem.destroy', "Excluído o Registro de n° {$series->id} com Sucesso!");

            return to_route('series.index');
        } else {

            $request->session()->put('mensagem.destroy', "Nenhuma identificação no registro foi encontrado!");

            return to_route('series.index');
        }
    }
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 03

#

-----------------------------------------------------------------------------------------------------------------------------------
##

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 04

#

-----------------------------------------------------------------------------------------------------------------------------------
##

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 05

#

-----------------------------------------------------------------------------------------------------------------------------------
##

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
